注意： ksymoops 在2.6中是没有用的。 请以原有格式使用Oops(来自dmesg，等等)。
忽略任何这样那样关于“解码Oops”或者“通过ksymoops运行”的文档。 如果你贴出运行过
ksymoops的来自2.6的Oops，人们只会让你重贴一次。

快速的总结
- - - - - - - - - - - - -

找到这个面向对象的程序设计系统（Oops）并将这个看起来像是复杂的问题发给内核区域的维护者。不要过于担心变成制造麻烦的人。如果你不确定发给这个负责相关的代码的人与你在做的内容有什么关系。如果出现重复的问题试着描述如何创建它。这是价值甚至超过了这个面向对象的程序设计系统（Oops）。

如果你发送的报告彻底难倒了他们，把它发送到linux-kernel@vger.kernel.org。谢谢你的帮助使Linux尽可能在力所能及的范围内稳定运行。

面向对象的程序设计系统（Oops）在哪里?
- - - - - - - - - - - - - - - - - - - - - - -

通常Oops文本由klogd和从内核缓冲区读取
交给syslogd写syslog文件,通常
/var/log/messages(取决于/etc/syslog.conf)。有时klogd死了,
在这种情况下,您可以运行dmesg >文件读取数据从内核
缓冲区并保存它。或者你可以猫/proc/kmsg >文件,不过你
在停止传输,必须打破kmsg是一个“永不落幕”文件。
如果机器有严重,不能输入命令或坠毁
磁盘不可用,那么你有三个选择:-

(1)手从屏幕复制文本和类型后机器
已经重新启动。混乱的但这是唯一的选择,如果你没有
计划在崩溃。或者,你可以采取的照片
数码相机的屏幕不好,但比
什么都没有。如果滚动的消息控制台,你
可能会发现,引导与高分辨率(例如,vga = 791)
会让你阅读更多的文本。(注意:这个需要vesafb,
所以不会帮助“早期”哦)

(2)引导与串行控制台(参见文档/ serial-console.txt),
运行一个零调制解调器第二个机器和捕获输出
使用你最喜欢的通信程序。小型计算机工作。

(3)使用Kdump(见文档/ Kdump / kdump.txt),
从记忆中提取内核环缓冲区使用dmesg命令
在文档/ kdump / gdbmacros.txt gdbmacro。


完整信息
- - - - - - - - - - - - - - - - -

注意:下面的消息从李纳斯适用于2.4内核。我已经保存它
由于历史的原因,因为它仍然有些信息
适用。特别是,请忽略任何ksymoops引用。

来自:Linus Torvalds < torvalds@osdl.org >

如何追踪哦. .(原邮件给linux内核)

主要的技巧是有5年的经验与那些讨厌的哦
消息;-)

事实上,有些事情你可以使这一切变得更简单。我有两个
单独的方法:

gdb /usr/src/linux/vmlinux
gdb >拆卸< offending_function >

这是最简单的方式找到这个问题,至少如果错误报告
好了(这样的人——通过ksymoops得到运行
信息的功能和偏移量的函数
发生在)。

哦,它帮助如果报告发生在内核编译的
相同的编译器和类似的设置。

另一件事要做的就是拆卸“代码:“错误报告的一部分:
ksymoops使用正确的工具也会这样做,但是如果你没有的
工具你可以做一个愚蠢的计划:

xXX char str[]= " \ \ xXX \ xXX…”;
main(){ }

并与gcc编译- g,然后做“拆卸str”(“XX”
东西是值报告的哦,你可以剪切和粘贴
和取代的空间“x \”——这就是我做的,因为我太懒
编写一个程序来自动化这些)。

或者,您可以在脚本中使用shell脚本/ decodecode。
它的用法是:decodecode < oops.txt

接下来的十六进制字节代码:“可能(在某些架构)系列
的字节之前当前指令指针以及字节在
在当前指令指针。在某些情况下,一条指令
字节或字周围是< >(),在“< 86 >”或“(f00d)”。这些
< >()标记指示当前指令指针。的例子
可读性i386,分成多行:

代码:f9 0 f 8 d f9 00 00 00 8 d 42 0 c e8 dd 26 11 c7 a1 60 ea 2 b f9 8 b 50 08 a1
64 ea 2 b f9 8 d 34 82 8 b 1 e 85分贝74 6 d 8 b 15 60 ea 2 b f9 < 8 b > 43 04 39 42 54
7 e 04 40 89 42 54 8 b 43 04 3 b 05 00 f6 52 c0

最后,如果你想看到的代码从哪里来,你可以做

cd /usr/src/linux
使fs /缓冲区。错误发生在年代#或其他文件

然后你得到一个更好的主意比gdb会发生什么
拆卸。

现在的关键是将你所有的数据:C
来源(和一般的知识它_should_做什么),组装
清单和代码拆卸(另外注册抛弃你
也会从“哎呀”消息,可以看到_what_有用
的指针,当你有清单可以汇编
还与其他寄存器无论他们使用C表达式
)。

本质上,你只是看看不匹配(在本例中它是
“代码”不匹配的拆卸与编译器所生成的)。
然后你需要找到_why_他们不匹配。通常很简单——你
看到代码使用一个空指针,然后你看代码和
想知道空指针到达那里,如果它是一个有效的事情
你检查它。

现在,如果有人认为这是耗时的,需要
一些少量的浓度,你是对的。这就是为什么我要吗
大部分只是忽略任何恐慌报告说,没有符号表
信息等抬头:它只是太难以查(我有一些
程序来搜索特定模式的内核代码段,和
有时我可以查找这样的恐慌,但是
真的需要很好的知识的内核就可以
挑选合适的序列等)

_Sometimes_碰巧我只是看到反汇编代码序列
立即从恐慌,我知道它来自哪里。这是当
我担心我这样做已经太久;-)

莱纳斯


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
笔记哦和klogd跟踪:

为了帮助莱纳斯和其他内核开发人员有
实质性支持纳入klogd处理保护
的缺点。为了完全支持至少地址解析
1.3版本的-pl3 sysklogd包应该使用。

保护故障发生时自动klogd守护进程
翻译重要的内核日志消息的地址
象征性的等价物。这翻译然后内核消息
转发klogd使用通过任何报告机制。的
保护错误消息可以简单地减少消息的文件
和转发到内核开发人员。

两种类型的地址解析由klogd执行。第一个是
静态的翻译,第二个是动态的翻译。静态
翻译使用系统。映射文件的方式
ksymoops。为了实现静态翻译klogd守护进程
必须能够找到一个映射文件系统守护进程的初始化时间。
看到klogd手册页获得信息klogd搜索地图
文件。

当内核可加载模块动态地址转换是很重要的
正在使用。因为内核模块分配的内存
内核的动态内存池没有固定的位置
模块或函数的开始和符号的模块。

内核支持系统调用允许一个程序来确定
在内存中加载的模块及其位置。使用这些
系统调用klogd守护进程建立一个可以使用的符号表
调试一个保护故障发生在一个可加载的内核模块。

在最低klogd将提供模块的名称
生成的故障保护。可能会有额外的符号
可加载的模块的信息如果开发人员选择
导出符号信息的模块。

由于内核模块可以是动态的,必须有一个环境
机制改变时通知klogd守护进程模块
环境发生。可用的命令行选项
允许klogd信号当前执行守护进程的象征
信息应该刷新。看到klogd手册页面
信息。

一个补丁修改包含在sysklogd分布
modules-2.0.0包自动信号klogd每当一个模块
加载或卸载。应用此修补程序提供
无缝支持调试保护故障发生
内核可加载模块。

下面是一个例子的保护故障可加载模块
由klogd处理:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
8月29日09:51:01 blizard内核:无法处理内核虚拟地址f15e97cc分页请求
8月29日09:51:01 blizard内核:当前- > tss。cr3 = 0062 d000,% cr3 = 0062 d000
8月29日09:51:01 blizard内核:* pde = 00000000
8月29日09:51:01 blizard内核:哦:0002
8月29日09:51:01 blizard内核:CPU:0
0010年8月29日09:51:01 blizard内核:EIP::[哎呀_oops + 16/3868):
8月29日09:51:01 blizard内核:EFLAGS:00010212
315年8月29日09:51:01 blizard内核:eax:e97cc ebx:003 a6f80交易所:001 be77b edx:00237 c0c
8月29日09:51:01 blizard内核:应急服务国际公司:00000000 edi:bffffdb3 ebp:00589法郎esp:00589 f8c
0018年8月29日09:51:01 blizard内核:ds:es:0018 fs:002 b g:002 b ss:0018
8月29日09:51:01 blizard内核:过程oops_test(pid):3374年,过程nr:21日stackpage = 00589000)
315年8月29日09:51:01 blizard内核栈:e97cc 0100 f98 00589 b0b4 bffffed4 0012 e38e 00240 c64 003 a6f80 00000001
8月29日09:51:01 blizard内核:00000000 0010 0010 bfffff00 a7fa 00237810 00000001 00237810 bfffff00
8月29日09:51:01 blizard内核:bffffdb3 bffffed4 ffffffda 0000002 b 0007002 b 0000002 b 0000002 b 00000036
8月29日09:51:01 blizard内核调用跟踪:[哎呀_oops_ioctl + 48/80):[_sys_ioctl + 254/272)(_system_call + 82/128)
8月29日09:51:01 blizard内核代码:c7 00 05 00 00 00 eb 08年90 90 90 90 90 90 90 90 89 ec 5 d c3
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

G.W.•维特斯坦博士肿瘤学研究Div。计算设备
罗杰•马里斯癌症中心互联网:greg@wind.rmcc.com
820年4日圣N。
法戈,ND 58122
电话:701-234-7556


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
污染的内核:

一些哦报告包含字符串的污染:“之后的计划
计数器。这表明内核已经被一些污染
机制。字符串是紧随其后的是一系列位敏
字符,每个代表一个特定的污染值。

1:‘G’如果所有模块加载GPL或兼容的许可证,“P”
任何专有模块已经加载。模块没有
MODULE_LICENSE或MODULE_LICENSE这并不认可
insmod GPL兼容的认为是专有的。

2:“F”如果任何模块加载武力“insmod - F”,“如果所有
模块被加载正常。

3:“年代”如果哦发生在SMP的内核运行在硬件上
没有安全认证多处理器运行。
目前这只发生在各种速龙不是
SMP的能力。

4:‘R’如果一个模块卸载武力“rmmod - f”,“如果所有
模块正常卸载。

5:“M”如果任何处理器报告了一台机器检查例外,
“如果没有机器检查例外发生。

6:' B '如果发现一个坏页面引用或释放页面功能
一些意想不到的页面的旗帜。

7:“U”如果一个用户或用户应用程序专门要求
污染的标志被设置,否则“。

8:' D '如果内核最近去世,即有一个哦或错误。

9:' A '如果ACPI表已被覆盖。

10:' W '如果一个警告此前发布的内核。
(尽管一些警告可能设置更具体的污染标志。)

11:' C '如果一个分段驱动程序被加载。

12:“我”如果内核工作平台中的一个严重的错误
固件(BIOS或类似)。

13:“O”如果一个externally-built(“树上的”)模块已经加载。

14:“E”如果一个无符号的模块已经加载到内核中支持
模块的签名。

15:“L”如果一个软禁售此前发生在系统。

16:“K”如果内核打补丁的生活。

的主要原因的污染:字符串是告诉内核
调试器如果这是一个干净的内核或如果任何异常
发生。污染是永恒的:即使一个冒犯模块
卸载,污染值仍表明内核不是
值得信赖。

